ES6 / ECMA Script 2015.

let:
====
It's a new keyword introduced to define variables with new features.
 
Adding new features to "var" keyword will generate many backward compatability issues. So, introduced 'let' keyword.

Variable hoisting with var:
---------------------------
var doWork = function(){
	return x;
} // Return error.

var doWork = function(flag){
    var x;
    if(flag){
        x = 3;
    }	
    return x;
} // Don't get error.

var doWork = function(flag){
    if(flag){
        var x = 3; //This Variable will be hoisted
    }	
    return x;
} // We should get error. But, we don't get because the variable x is hoisted to top of the function.

Function hoisting:
------------------
Function declarations are also hoisted.
// doWork is function name / identifier
doWork();

function doWork() {
  console.log("test");
}

Functions assigned to variables are not hoisted.
doWork();

var doWork = function(){
    console.log("test");
}

variables defined with "let" are not hoisted.

Scope of the let Variable limited to it's current block.
var doWork = function(flag){
    if(flag){
        let x = 3;
    }
    return x; 
}
doWork(false); 
x is not hoisted above. // Reference error: x is not defined

doWork(true); 
x scope is limited to it's block. // Reference error: x is not defined
The rule applies for all kind of blocks like for, switch etc..

Re-declaration not allowed within the same block.
var doWork = function(){
    var x = 10;
    var x = 12; // No Error with var
    return x; 
}

var doWork = function(){
    let x = 10;
    let x = 12; // Syntax error. 
    return x; 
}

var doWork = function(){
    let x = 10;
    var x = 12; // Syntax error. 
    return x; 
}

** This re-declaration rule applies in only that block **

(function(){
    let x = 10;
    let doWork = function(){
        let x = 12;
        console.log(x);
        return x; 
    }
    doWork();
})();

Summary of 'let' keyword:
-------------------------
* Scope of a variable defined with "let" is block level.So,variables are not hoisted to top.
* Re-declaration not allowed within the same block.

const:
======
'const' keyword is introduced in ES6 to define constants.

const LIMIT = 10;

LIMIT = 20; // Give an error, can't change the constants value.

Scope of const also block level.
(function(){
	const test = 10;
	let doWork = function(){
		const test = 20;
		console.log(test);
    } 
    doWork();
})();

Summary of 'const' keyword:
---------------------------
* Scope of constants is block level.So,constants are not hoisted to top.
* Re-declaration not allowed within the same block. And, we can't change the value of a constant.

Destructuring:
==============
Destructuring is a new way to assign values to variables.

let x = 2;
let y = 3; // Assigning values in normal way.

let [x, y] = [2, 3];

[x, y] = [y, x]; //Swaping the values

The left side value is not actully array. It looks like an array. Arrays/Objects found on left side of assignment operator are not Arrays/Objects, we are dealing with individual variables at a time.

If we find array symbol[] / object symbol{} on the left side of assignment operator, we can understand destructuring is used in that statement.

let [x, y] = [2, 3]; // Define and assign number of variables at a time.

let [a, b] = [1,2,3];
let [, c, d] = [1,2,3];
let [x, y, z] = [1,2]; // Will get z as undefined

// Assign values using function
function doWork(){
    return [1, 2];
}
let [x, y] = doWork();

All the above are array destructuring. 

Object destructuring:
---------------------
let {firstName: first, lastName: last} = {firstName: "John", lastName: "Papa"};

let {firstName: first, lastName: last, age: age} = {firstName: "John", lastName: "Papa"};

let {firstName: first, lastName: last, social: {twitter: twtr}} = {firstName: "John", lastName: "Papa", social: {twitter: "twId", fb: "fbId"}};
Tip to remember syntax: Simply copy object to the left side and replace values with variable names.

If we want to use same key name then we don't need to specify the variable name.

let {firstName, lastName, social: {twitter}} = 
    {
        firstName: "John", 
        lastName: "Papa", 
        social: {twitter: "twId", fb: "fbId"}
    };
console.log(firstName);
console.log(lastName);
console.log(twitter);

Destructuring with function parameters:
---------------------------------------
let hitServer = function(url, {data, cache, headers}){
    console.log(data);
    console.log(cache);
    console.log(headers);
    return cache; 
}

hitServer("/users", {
    data: "test",
    cache: true,
    headers: ["header1", "header2"]
});

Default parameters:
===================
ES5:
----
var doWork = function(name){
    name = name || 'John';
    console.log(name);
}
doWork("Peter");

ES6:
----
let doWork = function(name = "John"){
    console.log(name);
}
doWork(); // Not passing name
doWork("Peter"); // passing name
doWork(undefined); // passing undefined - name is 'John'
doWork(null); // passing null - name is 'null'
null and undefined are not same in Javascript.
undefined - existed but empty
null - not existed

If we intentially pass null to function then Default parameters consider that null value.
let doWork = function(a = 1, b = 2, c = 3){
    console.log(a);
    console.log(b);
    console.log(c);
}
doWork(5, undefined);

Default parameters in destructuring:
------------------------------------
let hitServer = function(url, {data = "testData", cache, headers}){
    console.log(data);
    console.log(cache);
    console.log(headers);
    return cache; 
}

hitServer("/users", {
    cache: true,
    headers: ["header1", "header2"]
});

Rest parameters:
================
Rest of the parameters in a function.
If the number of parameters are not fixed we can use rest parameters.

ES5:
----
var doWork = function(){
    console.log(arguments);
    for(var i=0; i<=arguments.length; i++){
        console.log(arguments[i]);
    }

    /* console.log(typeof arguments);
    arguments.forEach(function(val){ // forEach function will fail, because arguments is not real array. It's array kind of value.
        console.log(val);
    }); */
}
doWork("john", 1, 2, 3, 4);

ES6:
----
doWork("john", 1, 2, 3, 4);

let doWork = function(name, ...grades){
    console.log(name);
    console.log(grades); // Here we receive real array
}

doWork("john", 1, 2, 3, 4);
doWork("john"); // get grades as empty array

Rest parameter must be last formal parameter

let doWork = function(firstName, ...grades, lastName){
    console.log(name);
    console.log(grades);
}

doWork("John", 1, 2, 3, 4, "doe");

Rest parameters are part of function defination.

Spread operator:
================
spread is negation to Rest.
It is part of the function calling statement or other.

let doWork = function(x, y, z){
    console.log(x);
    console.log(y);
    console.log(z);
}

let arr = [1,2,3];
doWork(...arr);
doWork(...[4, 5, 6]);

build new arrays:
let a = [4,5,6];
let b = [1,2,3,...a,7,8,9];

Template literals:
==================
Useful to build dynamic strings easily.

Template literals starts and end with Backtic(`). ${x} replace the value of x in template literal string.

Substitute the values and Execute the expressions:
let x=1,y=2;
let template = `${x} add ${y} is ${x+y}`;

New lines don't break the code:
let html = `<div>
	<span>test</span>
</div>`;

` - Back tick.

Arrow Functions:
================
Two benifits
1. shorter syntax
2. No binding of this. "this" is not bound in arrow functions.
    - Arrow functions don't contain this, prototype, arguments property.

Syntax:
var multiply = function(x, y){
    return x*y;
};

var multiply = (x, y) => {return x*y;};

Curly brackets are not required if only one expression is present.

The symbol '=>' is called FAT ARROW.

var multiply = (x, y) => x*y;

Parentheses are optional when only one parameter is present

var strToArr = function(str){
    return str.split(" ");
};

var strToArr = str => str.split(" ");

Usage:
var smartPhones = [
    { name:'iphone', price:649 },
    { name:'Galaxy S6', price:576 },
    { name:'Galaxy Note 5', price:489 }
];

smartPhones.map(
    function(smartPhone) {
        return smartPhone.price;
    }
);

smartPhones.map(smartPhone=>smartPhone.price);

2. No binding of this. "this" is not bound in arrow functions.

Every function define it's own this.

Different shades of this:
-------------------------
In Functions,
function printThis(){
    console.log(this);
}
// This referring to "window" object

In methods,
var person = {
  firstName: "John",
  lastName: "Doe"
};

person.print = printThis;
person.print();
// This referring to "person" object

In a constructor,
function Person(){
    this.name = "John";
    this.print = function(){
        console.log(this);
    }   
}
var person = new Person();

Explicit this,

we can explicitly set this of a function.
function printThis(){
    console.log(this);
}

printThis.call(person);
printThis.apply(person);
var personPrint = printThis.bind(person);

In callbacks,

function Person() {
  this.age = 0;

  setInterval(function growUp() {
    this.age++;
    console.log(this.age);
  }, 1000);
}

var p = new Person();

Fix
function Person() {
    var that = this;
    that.age = 0;

    setInterval(function growUp() {
        that.age++;
        console.log(that.age);
    }, 1000);
}

var p = new Person();

Arrow way:
function Person(){
  this.age = 0;

  setInterval(() => {
    this.age++;
    console.log(this.age);
  }, 1000);
}

var p = new Person();

An arrow function does not create its own this context.

No binding of arguments

function test(a, b){
    console.log(arguments);
}
test(2, 3);

var f = (a,b) => {console.log(arguments)};
f(2, 3);

Arrow functions cannot be used as constructors and will throw an error when used with new.

var Foo = () => {};
var foo = new Foo(); // TypeError: Foo is not a constructor

Arrow functions do not have a prototype property.
var Foo = () => {};
Foo.prototype

Returning object:
-----------------
var func = (a, b) => a+b;

var func = () => { foo: 1 }; // Gives undefined.

var func = () => ({foo: 1});

don't give line brasks before arrow
var func = ()
           => 1;

Classes:
========
ES5:
----
Prototype is a hidden property of a function which helps in inheritance.
Every JavaScript function has a prototype property and it is empty by default.

function Person(first, last, age) {
    this.firstName = first;
    this.lastName = last;
    this.age = age;
}
Person.prototype.name = function() {
    return this.firstName + " " + this.lastName;
};

var person = new Person("john", "doe", 25)

inheritance using __proto__:
let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal;

ES6:
----
class Employee {
    doWork(){
        return "done!";
    }

    getName(){
        return "John";
    }
}

let emp = new Employee();

emp.doWork();

emp.prototype.doWork(); //classes use prototype property is used in the background.

Constructor: function in class which is invoked automatically while creating class

class Employee {
    constructor(name){
        this.empName = name;
    }
    doWork(){
        return "done!";
    }
    getName(){
        return this.empName;
    }
}

let emp = new Employee("john");

emp.empName // Returns employee name.

getters and setters:
--------------------
Getters and setters bind property to functions.

Getter return the peoperty and setter set the property.

class Employee {
    constructor(name){
        this.empName = name;
    }
	get name(){
		return this.empName;
    }
}

let emp = new Employee("john");
emp.name

class Employee {
    constructor(name){
        this.empName = name;
    }
	get empName(){
		return this.empName;
    }
	set empName(newName){
		return this.empName = newName;
    }
} // It will create erros. We should not have same name for property and method

class Person {
    constructor(name){
        this._name = name;
    }
	get name(){
		return this._name;
    }
	set name(newName){
		return this._name = newName;
    }
}
var person = new Person("John");
person.name

person.name = "Doe"; //Setting property

Inheretance:
------------
class Employee extends Person{
    doWork(){
        return `${this.name} is working`;
    }
}

var emp = new Employee("John");

// If we give empty constructor it throw error
class Employee extends Person{
    constructor(){
        
    }
    doWork(){
        return `${this.name} is working`;
    }
}

var emp = new Employee("John");

Super:
------
class Person {
    constructor(name){
        this._name = name;
    }
	get name(){
		return this._name;
    }
	set name(newName){
		return this._name = newName;
    }
}

class Employee extends Person{    
    // Without constructor works
    // With empty constructor doesn't work
    // With super(), without passsing name doesn't work
    constructor(name){
        //super(name);
    }    
    doWork(){
        return `${this.name} is working`;
    }
}

class Employee extends Person{
    constructor(name){
        super(name);
    }    
    doWork(){
        return `${this.name} is working`;
    }
}

class Employee extends Person{
    constructor(name, title){
        super(name);
        this.title = title;
    }    
    doWork(){
        return `${this.name} is working`;
    }
}

var emp = new Employee("John");

Super function invokes the parent class constructor and forward arguments from child class constructor to parent class constructor. 

Overrides:
----------
class Person {
    constructor(name){
        this.name = name;
    }
	get name(){
		return this._name;
    }
	set name(newName){
		return this._name = newName;
    }
    doWork(){
        console.log("person is working");
        return `person is working`;
    }
}

class Employee extends Person{
    constructor(name, title){
        super(name);
        this.title = title;
    }    
    doWork(){
        super.doWork(); // If we call this.doWork(), It will go to infinite loop.
        return `${this.name} is working`;
    }
}

var emp = new Employee("John");
emp.doWork();

Map:
====
Currently we are using Objects and arrays for data collections.

Array - indexed collection
Object - keyed collections

ES6 introduced Map and Set for data collections. These have some advantages in terms of performance and usage.

Map is a keyed collection just like Object. The main difference between Map and Object is, Map accept any kind of keys. But, Object accept only string keys.

we can say that Map is enhanced Object.

let map = new Map(); //To create map 

To check object size:
var myObj = {fname: "john", lname: "Doe"};
var objSize = Object.keys(myObj).length;

map.size - returns the size of a map.

To set property in map use set() method.
map.set('1', 'str1');   // a string key
map.set(1, 'num1');     // a numeric key
map.set(true, 'bool1'); // a boolean key

To get property in map use get() method.
map.get(1);
map.get('1');

map.size

Map can also use objects as keys.

let john = { name: "John" };

let visitsCountMap = new Map();

visitsCountMap.set(john, 123);

visitsCountMap.get(john)

map.set supports chaining.

map.set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');

We can set multiple values at the time of defining map.
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]); // Passed array of key, value pairs.

Create Map from Object:
var obj = {
    fname: 'john',
    lname: 'doe',
    age: 32
};

var entriesArr = Object.entries(obj);

var personMap = new Map(entriesArr);

map.keys() – returns an iterable for keys,
map.values() – returns an iterable for values,
map.entries() – returns an iterable for entries [key, value], it’s used by default in for..of.

Iteration:
----------
for..in, for, forEach are iterate over keys.
for..of - is iteration over values.

let recipeMap = new Map([
  ['cucumber', 500],
  ['tomatoes', 350],
  ['onion',    50]
]);

for(let vegetable of recipeMap.keys()) {
  console.log(vegetable);
}

for(let amount of recipeMap.values()) {
  console.log(amount);
}

for(let entry of recipeMap) { // the same as of recipeMap.entries()
  console.log(entry);
}

Note about syntax diff between Object.entries(obj) and recipeMap.entries();

The iteration goes in the same order as the values were inserted. Map guarantees that unlike a regular Object.

Map has a built-in forEach method, similar to Array:
recipeMap.forEach( (value, key, map) => {
  console.log(`${key}: ${value}`);
});

map.has(key) – returns true if the key exists, false otherwise.
map.delete(key) – removes the value by the key.
map.clear() – clears the map

Set:
====
The main methods are:

new Set(iterable) – creates the set, optionally from an array of values (any iterable will do).
set.add(value) – adds a value, returns the set itself.
set.delete(value) – removes the value, returns true if value existed at the moment of the call, otherwise false.
set.has(value) – returns true if the value exists in the set, otherwise false.
set.clear() – removes everything from the set.
set.size – is the elements count.

we can say that Set is enhanced Array.

set.get() - We don't have.

set contains only unique values. 
let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set keeps only unique values
console.log( set.size ); // 3

for(let user of set) {
  console.log(user.name); // John (then Pete and Mary)
}

To achieve uniqueness to array, it's a performance costly process. We do it generally with .indexOf() methods.

Set handles it by default.

Iteration:
----------
let set = new Set(["oranges", "apples", "bananas"]);

for(let value of set) console.log(value);

set.forEach((value, valueAgain, set) => {
  console.log(value);
});

Observe value, valueAgain in forEach.

set.keys() – returns an iterable object for values,
set.values() – same as set.keys, for compatibility with Map,
set.entries() – returns an iterable object for entries [value, value], exists for compatibility with Map.

WeakMap:
=======
We can think of WeakMap as a subset of Map. There are a few limitations on WeakMap.

The biggest limitation is, WeakMap is not iterable. So, no .entries(), .keys(), .values(), .forEach() and no .clear() methods.

Another limitation is WeakMap accepts only objects as keys. 

var map = new WeakMap()
map.set(1, 2)
// TypeError: 1 is not an object!
map.set(Symbol(), 2)
// TypeError: Invalid value used as weak map key

map.set({}, 2) // No error

WeakSet:
========

Object changes:
===============
object.assign() - to extend one object.
---------------

jQuery.extend( target [, object1 ] [, objectN ] );

var obj1 = {name: "John"};
var obj2 = {surname: "Doe"};

Object.assign(obj1, obj2);

obj1

Object shorthand notations:
---------------------------
var firstName = "John";
var lastName = "Doe";

var person = {firstName: firstName, lastName: lastName};

var person2 = {firstName, lastName};

var person = {
    doWork: function(){return "done"}
};

var person2 = {
    doWork(){return "done"}
};

Computed Properties:
--------------------
Dynamic properties with dynamic key/property names.

In ES5:
var name1 = "firstName";
var name2 = "lastName";

var obj = {};
obj[name1] = "John";
obj[name2] = "Doe";

In ES6:
var obj2 = {
    [name1]: "John",
    [name2]: "Doe",
};

We can write simple expressions in [].

Array changes and Comprehensions:
=================================
find and findIndex:
------------------
We use indexOf to search for an element in an array.

for conditional based search we use for loop.

We can use find() and findIndex() methods for conditional based search.

var numbersArr = [1,2,3];

array.find(function(item){
    return item == 2; // Returns first occurance value
});

array.findIndex(function(item){
    return item == 2; // Returns first occurance index
});

array.fill();

array.copyWithin();

Array.of():
var newArr = new Array(3,2,1); // [3,2,1]
var newArr = new Array(3); // [,,]

var newArr = Array.of(3);
var newArr = Array.of(3,2,1);

Array.from():
create array from array like objects.

var arrayLike = document.querySelectorAll('div');

array.entries()
Returns an array iterator with entries.
var names = ["John", "Doe", "Jim"];

var entries = names.entries(); // We can convert to map
var firstEntry = entries.next().value;

var keys = names.keys();

entries[Symbol.iterator]

Comprehensions:
---------------
Altername for array.map(function(){});

var arr = [for(i of [1,2,3]) i*i]; //[1,4,9]

var arr = [for(i of [1,2,3]) if(i<3) i*i]; //[1,4] //Filter the data

No support in chrome yet,
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Array_comprehensions

Symbols:
========
The data type symbol is a primitive data type.

Iterators and Generators:
=========================
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators

function* makeIterator(array) {
    yield* array;
}

var obj = {fname: "John", lname: "Doe"};

function* objGenerator(objParam){
	yield* Object.values(objParam);
};

var objIterator = objGenerator(obj);

obj[Symbol.iterator] = objIterator;

Array iterator example:
-----------------------
let numbers = [1,2,3,4];
numbers[Symbol.iterator]

numbers[Symbol.iterator]().next(()
Object {value: 1, done: false}

// Manual iterator
let iterator = numbers.values(); // don't work in chrome
let next = iterator.next();
while(!next.done){
    sum += next.value;
    next = iterator.next(); 
}

Modules:
========
Good authors divide their books into chapters and sections; good programmers divide their programs into modules.

In JavaScript each file is a module and all objects defined in the file belong to that module. 

One module export objects / constants / functions etc... using 'export' keyword, another module import using 'import' keywodrd.

//------ lib.js ------
export const sqrt = Math.sqrt;
export function square(x) {
    return x * x;
}
export function diag(x, y) {
    return sqrt(square(x) + square(y));
}

//------ main.js ------
import { square, diag } from 'lib';
console.log(square(11)); // 121
console.log(diag(4, 3)); // 5

You can also import the complete module:

//------ main.js ------
import * as lib from 'lib';
console.log(lib.square(11)); // 121
console.log(lib.diag(4, 3)); // 5

Browsers are not yet supporting modulets feature in ES6. So, we use module loaders like SystemJs, requireJs etc.. A module loader is a polyfill to support modules in un supported browsers.

Webpack is module bundler, which convert ES6 modules into ES5 modules.

https://medium.com/@svinkle/getting-started-with-webpack-and-es6-modules-c465d053d988

Code Repo: https://github.com/nagarjun-immadi/getting-started-with-webpack-and-es6-modules-the-demo

webpack commands:
----------------- 
webpack - build and exit.

webpack --watch  - build and keep on checking for changes.

Default Export:
---------------
An ES6 module can pick a default export, the main exported value. Default exports are especially easy to import.

The following ECMAScript 6 module is a single function:

//------ myFunc.js ------
export default function () {} // no semicolon!

//------ main1.js ------
import myFunc from 'myFunc';
myFunc();


An ECMAScript 6 module whose default export is a class looks as follows:
//------ MyClass.js ------
export default class {} // no semicolon!

//------ main2.js ------
import MyClass from 'MyClass';
const inst = new MyClass();

Above default exports have labels. We can default export direct values also.

export default 'abc';
export default foo();
export default /^xyz$/;
export default 5 * 7;
export default { no: false, yes: true };

Imports and exports must be at the top level.
// No conditional Imports
if (Math.random()) {
    import 'foo'; // SyntaxError
}

// You can’t even nest `import` and `export`
// inside a simple block:
{
    import 'foo'; // SyntaxError
}

Imports are hoisted: Therefore, it doesn’t matter where you mention them in a module and the following code works without any problems:

foo();
import { foo } from 'my_module';

Import all: 
import * as foo from 'foo';
foo.bar();

import * as lib from './lib';


Sites to Refer:
===============
http://javascript.info/

http://exploringjs.com/es6/

https://ponyfoo.com/articles/tagged/es6-in-depth