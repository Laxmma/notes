TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.

Installation:
=============
npm install -g typescript

tsc --version

tsc stands for "TypeScript Compiler".

tsc helloworld.ts => helloworld.ts compile to helloworld.js

Scripts: 1helloworld

Data Types:
===========
JavaScript is loosely typed language. But, typescript contains datatypes, we need to specify datatype of a variable while defining.

let isDone: boolean = false;

'isDone' is variable name, 'boolean' is datatype.

Boolean:
--------
boolean datatype holds true/false.

let isLoading: boolean = true;

Number:
-------
As like JavaScript, in TypeScript also all kinds of numbers comes under 'number' data type.

let decimalNum: number = 6;
let floatNum: number = 6.66;
let hexNum: number = 0xf00d;
let binaryNum: number = 0b1010;
let octalNum: number = 0o744;

String:
-------
'string' data type holds text data.

let color: string = "blue"; \\ Double quotes 
color = 'red'; \\ Single quotes
color = `green`; \\ Back tick

let fullName: string = `John Doe`;
let sentence: string = `Hello, my name is ${ fullName }.

Array:
------
let list: number[] = [1, 2, 3]; // Numerical array

let list: Array<number> = [1, 2, 3];

Tuple:
------
Tuple is a datatype used to express datatypes of array elements. 

// Declare a tuple type
let x: [string, number]; // 0th indexed value should be string, 1 indexed value should be number.

// Initialize it
x = ["hello", 10]; // OK

// Initialize it incorrectly
x = [10, "hello"]; // Error

x[1].substr(1) // Retuns error in compilation. So, runtime errors will be prevented.

x[3] = "world"; // 3rd index is out of the known indices. So, the value should be 'string | number' (union data type). 

x[6] = true; // Error, 'boolean' isn't 'string | number'

Enum:
-----
Enum is a datatype used to give friendly names to set of numerics.

// For example:
- Car racing game scores define the levels are 1000, 2000, 3000, 4000, 5000.
- Player will get access to some privileges on crossing the levels.[Ex: Access to power mode, able to purchase powerful cars etc...]

So, to handle these levels code looks like below.
if(score > 1000) {
    // Shift to power mode
} else if(score > 2000) {
    // Able to purchase sports car
} else if(score > 3000) {
    // Able to purchase racing car 
} etc ...

Let's give some names to the levels and handle the same code using enums. 

enum level {one = 1000, two = 2000, three = 3000, four = 4000, five = 5000};

Scripts: 2enum

enum level {one = 1000, two, three, four, five};
If we initialize one with 1000, two will become 1001, three will become 1002 etc..

enum level {one, two, three, four, five};
If we don't initialize one will become 0, two will become 1, three will become 2 etc..

We can know the name of enum with value.
level[2000]; // Return two

Any:
----
If we don't know type of variable at the time of writing the application we need to opt for 'any' kind. Sometimes we get data from user/third-party libraries.

let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; // okay, definitely a boolean

let list: any[] = [1, true, "free"];
list[1] = 100;

Void:
-----
'void' is a datatype opposite to 'any'. 'void' is used to represent the absence of having any type.

function warnUser(): void {
    alert("This is my warning message");
}

Declaring variables of type void is not useful because you can only assign undefined or null to them:

let unusable: void = undefined;

Null and Undefined:
-------------------
In TypeScript, both undefined and null actually have their own types named undefined and null respectively. Much like void, they’re not extremely useful on their own:

let u: undefined = undefined;
let n: null = null;

By default null and undefined are subtypes of all other types. That means you can assign null and undefined to something like number.

let num:number = 123;
num = null;

If we use strictNullChecks flag, we can't assign null and undefined to other datatyped variables.

tsc --strictNullChecks temp.ts

strictNullChecks is encouraged by TypeScript. As, it can avoid many common errors.

While using strictNullChecks, if we want to accept 'string' or 'undefined' or 'null' for a variable, we can use union datatypes string|undefined|null.

Never:
------
'never' type represents the type of values that never occur. For instance, never is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns.

function error(message: string): never {
    throw new Error(message);
}

function infiniteLoop(): never {
    while (true) {
    }
}

Type assertions:
----------------
Type assertions are a way to tell the compiler “trust me, I know what I’m doing.”

A type assertion is like a type cast in other languages.

Two syntaxes available for type assertion:
1. angle-bracket

let someValue: any = "this is a string";
let strLength: number = (<string>someValue).length;

2. as-syntax:

let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;

let and const:
==============
let x: number = 123;

const y: String = 'John Doe';

Destructuring:
==============
// Array Destructuring with datatypes
let [first, second]: [number, number] = [1,2];
console.log(first);
console.log(second);

// Object Destructuring with datatypes
let { a, b }: { a: string, b: number } = {a: 'foo', b: 12};
console.log(a);
console.log(b);

// Default values in destructuting
let { a, b = 1000 }: { a: string, b?: number } = {a: 'foo'};
console.log(a);
console.log(b);

'?' represents the optional value / parameter. If we don't specify '?' above, we will get error in compilation.

// Destructuring in functions
function f({ a, b=1000 }:{ a: string, b?: number } = { a: "test" }): void {
    console.log(a); // test
    console.log(b); // 1000
}
f();

function f({ a, b=1000 }:{ a: string, b?: number } = { a: "test", , b: 2000 }): void {
    console.log(a); // test
    console.log(b); //2000
}
f({ a: "test2", b:3000 });

function f({ a, b=1000 }:{ a: string, b?: number } = { a: "test", b: 2000 }): void {
    console.log(a); // test2
    console.log(b); // 3000
}
f({ a: "test2", b:3000 });

Spread Operator:
================
let first = [1, 2];
let second = [3, 4];
let bothPlus = [0, ...first, ...second, 5];

we can also spread objects:
let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
let search = { ...defaults, cuisine: "chinese" };

// Food 'rich' will be overwritten by spicy.
let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
let search = { food: "rich", ...defaults };

While spreading we will loose the methods in the spreaded Object.

