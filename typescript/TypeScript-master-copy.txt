TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.

Installation:
=============
npm install -g typescript

tsc --version

tsc stands for "TypeScript Compiler".

tsc helloworld.ts => helloworld.ts compile to helloworld.js

function Person() {
    this.name = 'John Doe';
    this.age = 25;
}

let personObj = new Person();

Data Types:
===========
JavaScript is loosely typed language. But, typescript contains datatypes, we need to specify datatype of a variable while defining.

let isDone: boolean = false;

'isDone' is variable name, 'boolean' is datatype.

Boolean:
--------
boolean datatype holds true/false.

let isLoading: boolean = true;

Number:
-------
As like JavaScript, in TypeScript also all kinds of numbers comes under 'number' data type.

let decimalNum: number = 6;
let floatNum: number = 6.66;
let hexNum: number = 0xf00d;
let binaryNum: number = 0b1010;
let octalNum: number = 0o744;

String:
-------
'string' data type holds text data.

let color: string = "blue"; \\ Double quotes 
color = 'red'; \\ Single quotes
color = `green`; \\ Back tick

let fullName: string = `John Doe`;
let sentence: string = `Hello, my name is ${ fullName }.

Array:
------
let list: number[] = [1, 2, 3]; // Numerical array

let list: Array<number> = [1, 2, 3];

Tuple:
------
Tuple is a datatype used to express datatypes of array elements. 

// Declare a tuple type
let x: [string, number]; // 0th indexed value should be string, 1 indexed value should be number.

// Initialize it
x = ["hello", 10]; // OK

// Initialize it incorrectly
x = [10, "hello"]; // Error

x[1].substr(1) // Retuns error in compilation. So, runtime errors will be prevented.

x[3] = "world"; // 3rd index is out of the known indices. So, the value should be 'string | number' (union data type). 

x[6] = true; // Error, 'boolean' isn't 'string | number'

Enum:
-----
Enum is a datatype used to give friendly names to set of numerics.

// For example:
- Car racing game scores define the levels are 1000, 2000, 3000, 4000, 5000.
- Player will get access to some privileges on crossing the levels.[Ex: Access to power mode, able to purchase powerful cars etc...]

So, to handle these levels code looks like below.
if(score > 1000) {
    // Shift to power mode
} else if(score > 2000) {
    // Able to purchase sports car
} else if(score > 3000) {
    // Able to purchase racing car 
} etc ...

Let's give some names to the levels and handle the same code using enums. 

enum level {one = 1000, two = 2000, three = 3000, four = 4000, five = 5000};
let score = 2500;
if(score <= level.one) {
    console.log('Shift to power mode');
} else if(score <= level.two) {
    console.log('Able to purchase sports car');
} else if(score <= level.three) {
    console.log('Able to purchase racing car'); 
} else if(score <= level.four){
    console.log('Able to purchase super car');
} else if(score <= level.five){
    console.log('Able to purchase flying car');
}
console.log(level[2000]);
enum newLevels {one = 1000, two, three, four, five};
console.log(newLevels);
enum latestLevels {one, two, three, four, five};
console.log(latestLevels);


enum level {one = 1000, two, three, four, five};
If we initialize one with 1000, two will become 1001, three will become 1002 etc..

enum level {one, two, three, four, five};
If we don't initialize one will become 0, two will become 1, three will become 2 etc..

We can know the name of enum with value.
level[2000]; // Return two

Any:
----
If we don't know type of variable at the time of writing the application we need to opt for 'any' kind. Sometimes we get data from user/third-party libraries.

let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; // okay, definitely a boolean

let list: any[] = [1, true, "free"];
list[1] = 100;

Void:
-----
'void' is a datatype opposite to 'any'. 'void' is used to represent the absence of having any type.

function warnUser(): void {
    alert("This is my warning message");
}

Declaring variables of type void is not useful because you can only assign undefined or null to them:

let unusable: void = undefined;

Null and Undefined:
-------------------
In TypeScript, both undefined and null actually have their own types named undefined and null respectively. Much like void, they’re not extremely useful on their own:

let u: undefined = undefined;
let n: null = null;

By default null and undefined are subtypes of all other types. That means you can assign null and undefined to something like number.

let num:number = 123;
num = null;

If we use strictNullChecks flag, we can't assign null and undefined to other datatyped variables.

tsc --strictNullChecks temp.ts

strictNullChecks is encouraged by TypeScript. As, it can avoid many common errors.

While using strictNullChecks, if we want to accept 'string' or 'undefined' or 'null' for a variable, we can use union datatypes string|undefined|null.

Never:
------
'never' type represents the type of values that never occur. For instance, never is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns.

function error(message: string): never {
    throw new Error(message);
}

function infiniteLoop(): never {
    while (true) {
    }
}

Type assertions:
----------------
Type assertions are a way to tell the compiler “trust me, I know what I’m doing.”

A type assertion is like a type cast in other languages.

Two syntaxes available for type assertion:
1. angle-bracket

let someValue: any = "this is a string";
let strLength: number = (<string>someValue).length;

2. as-syntax:

let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;

let and const:
==============
let x: number = 123;

const y: String = 'John Doe';

Destructuring:
==============
// Array Destructuring with datatypes
let [first, second]: [number, number] = [1,2];
console.log(first);
console.log(second);

// Object Destructuring with datatypes
let { a, b }: { a: string, b: number } = {a: 'foo', b: 12};
console.log(a);
console.log(b);

// Default values in destructuting
let { a, b = 1000 }: { a: string, b?: number } = {a: 'foo'};
console.log(a);
console.log(b);

'?' represents the optional value / parameter. If we don't specify '?' above, we will get error in compilation.

// Destructuring in functions
function f({ a, b=1000 }:{ a: string, b?: number } = { a: "test" }): void {
    console.log(a); // test
    console.log(b); // 1000
}
f();

function f({ a, b=1000 }:{ a: string, b?: number } = { a: "test", , b: 2000 }): void {
    console.log(a); // test
    console.log(b); //2000
}
f({ a: "test2", b:3000 });

function f({ a, b=1000 }:{ a: string, b?: number } = { a: "test", b: 2000 }): void {
    console.log(a); // test2
    console.log(b); // 3000
}
f({ a: "test2", b:3000 });

Spread Operator:
================
let first = [1, 2];
let second = [3, 4];
let bothPlus = [0, ...first, ...second, 5];

we can also spread objects:
let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
let search = { ...defaults, cuisine: "chinese" };

// Food 'rich' will be overwritten by spicy.
let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
let search = { food: "rich", ...defaults };

While spreading we will loose the methods in the spreaded Object.

Interfaces:
===========
Interfaces define the shape of a value. TypeScript always check whether the value is in specified format or not. This is called type-checking / duck typing / structural sub typing.

function printLabel(labelledObj: { label: string }) {
    console.log(labelledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);

Type checker checks for label in myObj. If it is not found, compiler will return error.

interface LabelledValue {
    label: string;
}

function printLabel(labelledObj: LabelledValue) {
    console.log(labelledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);

myObj contains 'size' property also. But, type checker checks for all the properties specified in the interface are available or not.

Optional Properties:
--------------------
Not all properties of an interface may be required. Some exist under certain conditions or may not be there at all.

Optional properties denoted by a ? at the end of the property name in the declaration.

interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
    let newSquare = {color: "white", area: 100};
    if (config.color) {
        newSquare.color = config.color;
    }
    if (config.width) {
        newSquare.area = config.width * config.width;
    }
    return newSquare;
}

let mySquare = createSquare({color: "black"});

Readonly properties:
--------------------
Some properties should only be modifiable when an object is first created. You can specify this by putting readonly before the name of the property.

interface Point {
    readonly x: number;
    readonly y: number;
}

let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!

TypeScript comes with a ReadonlyArray<T> type that is the same as Array<T> with all mutating methods removed, so you can make sure you don’t change your arrays after creation:

let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error! - can't assign ReadonlyArray to normal array. But, type assertion works.

a = ro as number[];

readonly vs const:
------------------
Variables use const whereas properties use readonly.

Function Types:
---------------
Interfaces can be used to describing function types.

To describe a function type with an interface, we give the interface a call signature. This is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type.

interface SearchFunc {
    (source: string, subString: string): boolean;
}

let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
    let result = source.search(subString);
    return result > -1;
}

For function types to correctly type-check, the names of the parameters do not need to match. We could have, for example, written the above example like this:

let mySearch: SearchFunc;
mySearch = function(src: string, sub: string): boolean {
    let result = src.search(sub);
    return result > -1;
}

Indexable Types:
----------------
interface StringArray {
    [index: number]: string;
}

let myArray: StringArray;
myArray = ["Bob", "Fred"];

we can make index signatures readonly in order to prevent assignment to their indices:

interface ReadonlyStringArray {
    readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = ["Alice", "Bob"];
myArray[2] = "Mallory"; // error! we can’t set myArray[2] because the index signature is readonly.

Class Types:
------------
interface ClockInterface {
    currentTime: Date;
}

class Clock implements ClockInterface {
    currentTime: Date;
    constructor(h: number, m: number) { }
}

we can also describe methods in an interface that are implemented in the class.

interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}

Interfaces describe the public side of the class, rather than both the public and private side. This prohibits exposing private side.

Extending Interfaces:
---------------------
Like classes, interfaces can extend each other. This allows you to copy the members of one interface into another, which gives you more flexibility in how you separate your interfaces into reusable components.

interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

let square = <Square>{};
square.color = "blue";
square.sideLength = 10;

An interface can extend multiple interfaces, creating a combination of all of the interfaces.

interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

let square = <Square>{};
square.color = "blue";
square.sideLength = 10;
square.penWidth = 5.0;

Interfaces Extending Classes:
-----------------------------
When an interface type extends a class type it inherits the members of the class but not their implementations.

Interfaces inherit even the private and protected members of a base class.

class Control {
    private state: any;
}

interface SelectableControl extends Control {
    select(): void;
}

Classes:
========
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

let greeter = new Greeter("world");

Inheritance:
------------
class Animal {
    move(distanceInMeters: number = 0) {
        console.log(`Animal moved ${distanceInMeters}m.`);
    }
}

class Dog extends Animal {
    bark() {
        console.log('Woof! Woof!');
    }
}

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();

super:
------
class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log("Galloping...");
        super.move(distanceInMeters);
    }
}

let sam = new Snake("Sammy the Python");
let tom: Animal = new Horse("Tommy the Palomino");

sam.move();
tom.move(34);

Public, private, and protected modifiers:
-----------------------------------------
public:
-------
By default all class members are public. We don’t need to mention it. But, we can use public explicitly.

class Animal {
    public name: string;
    public constructor(theName: string) { this.name = theName; }
    public move(distanceInMeters: number) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

private:
--------
When a member is marked private, it cannot be accessed from outside of its containing class.

class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

new Animal("Cat").name; // Error: 'name' is private;

protected:
----------
protected peoperties can be accessed within the class and only on own class instaces. Can't be accessed from outside or inherited class.

class Person {
    protected name: string;
    constructor(name: string) { this.name = name; }
}

class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name);
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee("Howard", "Sales");
console.log(howard.getElevatorPitch());
console.log(howard.name); // error

If we use 'protected' on constructor method, we can’t create object for it, but we can extend that class.

Readonly modifier:
------------------
we can make properties readonly by using the readonly keyword. Readonly properties must be initialized at their declaration or in the constructor. 

class Octopus {
    readonly name: string;
    readonly numberOfLegs: number = 8;
    constructor (theName: string) {
        this.name = theName;
    }
}
let dad = new Octopus("Man with the 8 strong legs");
dad.name = "Man with the 3-piece suit"; // error! name is readonly.

Parameter properties:
---------------------
In our last example, we had to declare a readonly member name and a constructor parameter theName in the Octopus class, and we then immediately set name to theName. This turns out to be a very common practice. Parameter properties let you create and initialize a member in one place. Here’s a further revision of the previous Octopus class using a parameter property:

class Octopus {
    readonly numberOfLegs: number = 8;
    constructor(readonly name: string) {
    }
}

Notice how we dropped theName altogether and just use the shortened readonly name: string parameter on the constructor to create and initialize the name member. We’ve consolidated the declarations and assignment into one location.

We can use any modifier like public, private, protected, and readonly before parameter properties.

Accessors (getters/setters):
----------------------------
let passcode = "secret passcode";

class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (passcode && passcode == "secret passcode") {
            this._fullName = newName;
        }
        else {
            console.log("Error: Unauthorized update of employee!");
        }
    }
}

let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    console.log(employee.fullName);
}

Static Properties:
------------------
Static members visible on the class itself rather than on the instances. 

class Grid {
    static origin = {x: 0, y: 0};
    calculateDistanceFromOrigin(point: {x: number; y: number;}) {
        let xDist = (point.x - Grid.origin.x);
        let yDist = (point.y - Grid.origin.y);
        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
    }
    constructor (public scale: number) { }
}

console.log(Grid.origin);

let grid1 = new Grid(1.0);
console.log(grid1.origin); // Get an error.

Abstract Classes:
-----------------
Abstract classes are base classes from which other classes may be derived. They may not be instantiated directly. Unlike an interface, an abstract class may contain implementation details for its members. The abstract keyword is used to define abstract classes as well as abstract methods within an abstract class.

abstract class Animal {
    abstract makeSound(): void;
    move(): void {
        console.log("roaming the earth...");
    }
}

Methods within an abstract class that are marked as abstract do not contain an implementation and must be implemented in derived classes.

abstract class Department {

    constructor(public name: string) {
    }

    printName(): void {
        console.log("Department name: " + this.name);
    }

    abstract printMeeting(): void; // must be implemented in derived classes
}

class AccountingDepartment extends Department {

    constructor() {
        super("Accounting and Auditing"); // constructors in derived classes must call super()
    }

    printMeeting(): void {
        console.log("The Accounting Department meets each Monday at 10am.");
    }

    generateReports(): void {
        console.log("Generating accounting reports...");
    }
}

let department: Department; // ok to create a reference to an abstract type
department = new Department(); // error: cannot create an instance of an abstract class
department = new AccountingDepartment(); // ok to create and assign a non-abstract subclass
department.printName();
department.printMeeting();
department.generateReports(); // error: method doesn't exist on declared abstract type

Class datatype:
---------------
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

let greeter: Greeter;
greeter = new Greeter("world");
console.log(greeter.greet());

Here 'greeter' is a variable of type Greeter.

Functions:
==========